
import asyncio
import os
import json
import time
import glob
import logging
import traceback
import math
import pandas as pd
import numpy as np
from collections import deque
from decimal import Decimal, ROUND_HALF_UP
from datetime import datetime
from typing import Dict, Any, Optional, Tuple, List

from dotenv import load_dotenv

# Inherit from BaseExchangeClient or simply use LighterClient
# Since we need 2 connections, we will wrap them in a strategy class
from exchanges.lighter import LighterClient, OrderResult
from helpers.logger import TradingLogger

# Load environment variables
load_dotenv()

# Configure Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("logs/lighter_arb.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("LighterGoldArb")

from fetch_lighter_history import fetch_history_stats

class LighterGoldArb:
    def __init__(self):
        self.paxg_market_id = 48  # PAXG/USDC (Spot)
        self.xau_market_id = 92   # XAU/USD (Perp)
        
        # Strategy Parameters
        self.window_size = 21600 # 6 Hours (Optimized High-Frequency Window)
        self.z_entry_threshold = 1.1 # Optimized Robust Plateau
        self.z_exit_threshold = 0.0 # Mean Reversion Exit
        self.max_slippage = Decimal("0.001")  # 0.1%
        
        # Risk Management
        self.trade_amount_usdc = Decimal("100") # Target trade value in USDC
        
        # High-Frequency Rolling Window (Stores raw spreads approx 1s interval)
        self.spread_window = deque(maxlen=self.window_size)
        
        # Clients
        self.client_paxg: Optional[LighterClient] = None
        self.client_xau: Optional[LighterClient] = None
        
        # State
        self.position_state = "NEUTRAL" # NEUTRAL, LONG_PAXG_SHORT_XAU, SHORT_PAXG_LONG_XAU
        self.last_trade_time = 0
        self.min_trade_interval = 5 # seconds
        
        # Audit Log
        self.audit_log_file = "logs/live_audit.log"

    def load_recent_data_from_collector(self):
        """
        Bootstrap the deque by reading local CSV files generated by lighter_data_collector.py
        """
        try:
            logger.info("Bootstrapping: Loading recent CSV data...")
            files = sorted(glob.glob("data/market_data_*.csv"))
            if not files:
                logger.warning("Bootstrapping: No CSV files found. Starting cold.")
                return

            # Read only last few files to save IO (enough to cover 6h)
            recent_files = files[-8:] if len(files) > 8 else files
            
            logger.info(f"Reading files: {[os.path.basename(f) for f in recent_files]}")
            
            df_list = []
            for f in recent_files:
                try:
                    df = pd.read_csv(f)
                    df_list.append(df)
                except Exception as e:
                    logger.warning(f"Error reading {f}: {e}")
            
            if not df_list: return

            full_df = pd.concat(df_list, ignore_index=True)
            full_df = full_df.sort_values('timestamp')
            
            # Filter Closed Market (if column exists)
            if 'is_market_open' in full_df.columns:
                full_df['is_market_open'] = full_df['is_market_open'].astype(str).map({'True': True, 'False': False, '1': True, '0': False, '1.0': True, '0.0': False, 'nan': True})
                full_df['is_market_open'] = full_df['is_market_open'].fillna(True)
                full_df = full_df[full_df['is_market_open'] == True]

            # Calculate Spread
            full_df['paxg_mid'] = (full_df['paxg_best_bid'] + full_df['paxg_best_ask']) / 2
            full_df['xau_mid'] = (full_df['xau_best_bid'] + full_df['xau_best_ask']) / 2
            full_df['spread_diff'] = full_df['paxg_mid'] - full_df['xau_mid']
            
            # Extract last N rows needed
            needed = self.window_size
            recent_spreads = full_df['spread_diff'].tail(needed).tolist()
            
            # Fill deque
            count = 0
            for s in recent_spreads:
                if not pd.isna(s):
                    self.spread_window.append(Decimal(str(s)))
                    count += 1
            
            logger.info(f"Bootstrapping: Loaded {count} data points from CSV.")

        except Exception as e:
            logger.error(f"Bootstrapping Failed: {e}")
            logger.error(traceback.format_exc())

    async def initialize(self):
        """Initialize connections and warmup."""
        logger.info("Initializing Lighter Gold Arb Bot (High-Frequency Mode)...")
        
        # 1. Bootstrapping
        self.load_recent_data_from_collector()
        
        # Init Clients
        
        # Init Clients
        config_paxg = {
            "ticker": "PAXG", # Market 48
            "contract_id": self.paxg_market_id,
            "tick_size": Decimal("0.01"), # Will be updated from market info
            "close_order_side": "sell", # Default, not strictly used here
            "account_index": int(os.getenv('LIGHTER_ACCOUNT_INDEX', '0')),
        }
        
        config_xau = {
            "ticker": "XAU", # Market 92
            "contract_id": self.xau_market_id,
            "tick_size": Decimal("0.01"),
            "close_order_side": "sell",
            "account_index": int(os.getenv('LIGHTER_ACCOUNT_INDEX', '0')),
        }
        
        # Helper class to mock Config object required by LighterClient
        class Config:
            def __init__(self, d):
                for k, v in d.items():
                    setattr(self, k, v)
        
        self.client_paxg = LighterClient(Config(config_paxg))
        self.client_xau = LighterClient(Config(config_xau))
        
        # Connect
        await asyncio.gather(
            self.client_paxg.connect(),
            self.client_xau.connect()
        )
        
        # Fetch actual market details (tick size, multipliers) 
        # LighterClient loads some of this internally on connect/get_market_config
        # We trigger it manually ensuring we have correct precision info
        await self.client_paxg.get_contract_attributes()
        await self.client_xau.get_contract_attributes()
        
        logger.info(f"Connected. PAXG Tick: {self.client_paxg.config.tick_size}, XAU Tick: {self.client_xau.config.tick_size}")
        
    async def get_mid_prices(self) -> Tuple[Optional[Decimal], Optional[Decimal]]:
        """Get Mid Prices for both assets."""
        try:
            # PAXG
            paxg_bid, paxg_ask = await self.client_paxg.fetch_bbo_prices(self.paxg_market_id)
            if not paxg_bid or not paxg_ask: return None, None
            paxg_mid = (paxg_bid + paxg_ask) / 2
            
            # XAU
            xau_bid, xau_ask = await self.client_xau.fetch_bbo_prices(self.xau_market_id)
            if not xau_bid or not xau_ask: return None, None
            xau_mid = (xau_bid + xau_ask) / 2
            
            return paxg_mid, xau_mid
        except Exception as e:
            logger.error(f"Error fetching prices: {e}")
            return None, None

    def calculate_stats(self):
        """Calculate Moving Average and StdDev based on High-Frequency Window (Deque)."""
        if len(self.spread_window) < self.window_size:
            return None, None
            
        # Use numpy for speed
        spreads_float = [float(x) for x in self.spread_window]
        avg = np.mean(spreads_float)
        std_dev = np.std(spreads_float)
        
        return Decimal(str(avg)), Decimal(str(std_dev))

    def check_slippage(self, side: str, amount: Decimal, client: LighterClient, market_id: int) -> bool:
        """
        Check if market order would slip more than max_slippage.
        This requires checking orderbook depth. 
        """
        try:
            if not hasattr(client, 'ws_manager') or not client.ws_manager:
                logger.warning("WS Manager not available for slippage check")
                return False
                
            ob = client.ws_manager.order_book
            book_side = 'asks' if side == 'buy' else 'bids'
            
            # Sort levels
            levels = sorted(ob[book_side].items(), key=lambda x: x[0], reverse=(book_side == 'bids'))
            
            filled = Decimal(0)
            weighted_price = Decimal(0)
            remaining = amount
            
            for price_float, size_float in levels:
                price = Decimal(str(price_float))
                size = Decimal(str(size_float))
                
                take = min(size, remaining)
                weighted_price += take * price
                filled += take
                remaining -= take
                
                if remaining <= 0:
                    break
            
            if filled < amount:
                logger.warning(f"Not enough liquidity for {amount} {side}")
                return False
                
            avg_exec_price = weighted_price / filled
            best_price = Decimal(str(levels[0][0]))
            
            slippage = abs(avg_exec_price - best_price) / best_price
            
            if slippage > self.max_slippage:
                logger.warning(f"Slippage too high: {slippage} > {self.max_slippage}")
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"Error checking slippage: {e}")
            return False

    async def execute_leg(self, client: LighterClient, market_id: int, side: str, quantity: Decimal) -> OrderResult:
        """Execute a single leg (Market Order)."""
        # Get Price
        best_bid, best_ask = await client.fetch_bbo_prices(market_id)
        if not best_bid or not best_ask:
            return OrderResult(False, None, "No BBO prices")

        if side == 'buy':
            # Buy: Price = Best Ask * (1 + slippage_buffer)
            price = best_ask * (Decimal("1") + self.max_slippage)
        else:
            # Sell: Price = Best Bid * (1 - slippage_buffer)
            price = best_bid * (Decimal("1") - self.max_slippage)
            
        # Round Price
        price = client.round_to_tick(price)
        
        # Place Order
        logger.info(f"Executing {side} {quantity} @ ~{price} on Market {market_id}")
        return await client.place_limit_order(str(market_id), quantity, price, side)

    def log_audit(self, side_paxg, price_paxg, size_paxg, hash_paxg, side_xau, price_xau, size_xau, hash_xau, spread, z_score):
        """Log trade to audit file."""
        timestamp = datetime.now().isoformat()
        log_entry = (
            f"{timestamp} | "
            f"PAXG: {side_paxg} {size_paxg}@{price_paxg} ({hash_paxg}) | "
            f"XAU: {side_xau} {size_xau}@{price_xau} ({hash_xau}) | "
            f"Spread: {spread:.4f} | Z-Score: {z_score:.4f}\n"
        )
        with open(self.audit_log_file, "a") as f:
            f.write(log_entry)

    async def run_strategy(self):
        """Main Strategy Loop."""
        logger.info("Starting Strategy Loop (High-Frequency)...")
        
        while True:
            try:
                # 1. Get Market Data
                paxg_mid, xau_mid = await self.get_mid_prices()
                
                if not paxg_mid or not xau_mid:
                    logger.warning("Price data unavailable, skipping...")
                    await asyncio.sleep(1)
                    continue
                
                # 2. Update stats
                spread = paxg_mid - xau_mid
                
                # High-Freq Accumulation
                self.spread_window.append(spread)
                
                # Check Window
                if len(self.spread_window) < self.window_size:
                    if len(self.spread_window) % 1000 == 0:
                        logger.info(f"Warming up window... {len(self.spread_window)}/{self.window_size}")
                    await asyncio.sleep(1)
                    continue
                    
                avg, std_dev = self.calculate_stats()
                if std_dev == 0: std_dev = Decimal("0.0001") # Avoid div by zero
                
                z_score = (spread - avg) / std_dev
                
                # Throttle Log (every 100 ticks ~ 100s)
                if len(self.spread_window) % 100 == 0:
                    logger.info(f"Spread: {spread:.2f} | Avg: {avg:.2f} | Std: {std_dev:.2f} | Z: {z_score:.2f}")
                
                # 3. Check Logic
                current_time = time.time()
                if current_time - self.last_trade_time < self.min_trade_interval:
                    await asyncio.sleep(0.5)
                    continue
                
                action = None
                
                # Entry: Sell PAXG / Buy XAU (Spread positive > threshold)
                if self.position_state == "NEUTRAL":
                    if z_score > self.z_entry_threshold:
                        action = "OPEN_SHORT_SPREAD" # Sell PAXG, Buy XAU
                    elif z_score < -self.z_entry_threshold:
                        action = "OPEN_LONG_SPREAD"  # Buy PAXG, Sell XAU
                        
                # Exit
                elif self.position_state == "SHORT_SPREAD": # Sold PAXG, Long XAU
                    if z_score <= self.z_exit_threshold: # Reverted
                        action = "CLOSE_SHORT_SPREAD" # Buy PAXG, Sell XAU
                        
                elif self.position_state == "LONG_SPREAD": # Bought PAXG, Short XAU
                    if z_score >= -self.z_exit_threshold: # Reverted
                        action = "CLOSE_LONG_SPREAD" # Sell PAXG, Buy XAU
                
                if action:
                    await self.execute_action(action, paxg_mid, xau_mid, spread, z_score)
                    
            except Exception as e:
                err_str = str(e)
                if "429" in err_str or "limit" in err_str.lower():
                    logger.warning(f"Rate Limit Hit: {e}. Sleeping 30s...")
                    await asyncio.sleep(30)
                else:
                    logger.error(f"Loop Error: {e}")
                    traceback.print_exc()
                 
            await asyncio.sleep(1)

    async def execute_action(self, action, paxg_price, xau_price, spread, z_score):
        logger.info(f"TRIGGERED: {action} at Z={z_score:.2f}")
        
        # Calculate Quantities
        # 1:1 Value
        qty_paxg = (self.trade_amount_usdc / paxg_price).quantize(Decimal("0.000001")) # Lighter PAXG might behave differently? 
        # Actually PAXG is 18 decimals, but Lighter API takes 'Base Amount' in specific units.
        # The LighterClient handles conversion if we pass Decimal. 
        # But we must check min size.
        
        qty_xau = (self.trade_amount_usdc / xau_price).quantize(Decimal("0.0001"))
        
        paxg_side = None
        xau_side = None
        
        if action == "OPEN_SHORT_SPREAD":
            paxg_side, xau_side = "sell", "buy"
            new_state = "SHORT_SPREAD"
        elif action == "OPEN_LONG_SPREAD":
            paxg_side, xau_side = "buy", "sell"
            new_state = "LONG_SPREAD"
        elif action == "CLOSE_SHORT_SPREAD":
            paxg_side, xau_side = "buy", "sell"
            new_state = "NEUTRAL"
        elif action == "CLOSE_LONG_SPREAD":
            paxg_side, xau_side = "sell", "buy"
            new_state = "NEUTRAL"
            
        # Slippage Check
        chk_paxg = self.check_slippage(paxg_side, qty_paxg, self.client_paxg, self.paxg_market_id)
        chk_xau = self.check_slippage(xau_side, qty_xau, self.client_xau, self.xau_market_id)
        
        if not chk_paxg or not chk_xau:
            logger.warning("Slippage Check Failed. Aborting trade.")
            return

        # Execute
        logger.info(f"Sending Orders -> PAXG: {paxg_side} {qty_paxg}, XAU: {xau_side} {qty_xau}")
        
        res_paxg, res_xau = await asyncio.gather(
            self.execute_leg(self.client_paxg, self.paxg_market_id, paxg_side, qty_paxg),
            self.execute_leg(self.client_xau, self.xau_market_id, xau_side, qty_xau)
        )
        
        # Verify
        if res_paxg.success and res_xau.success:
            logger.info("TRADE SUCCESSFUL")
            self.position_state = new_state
            self.last_trade_time = time.time()
            self.log_audit(paxg_side, paxg_price, qty_paxg, res_paxg.order_id, 
                           xau_side, xau_price, qty_xau, res_xau.order_id, spread, z_score)
        else:
            logger.critical(f"PARTIAL/FAILED EXECUTION! PAXG: {res_paxg.success}, XAU: {res_xau.success}")
            # Recovery logic could go here (e.g. close the successful leg)
            # For now just log critical
            self.log_audit(paxg_side, paxg_price, qty_paxg, f"ERR:{res_paxg.error_message}", 
                           xau_side, xau_price, qty_xau, f"ERR:{res_xau.error_message}", spread, z_score)

    async def shutdown(self):
        logger.info("Shutting down...")
        if self.client_paxg: await self.client_paxg.disconnect()
        if self.client_xau: await self.client_xau.disconnect()

if __name__ == "__main__":
    bot = LighterGoldArb()
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    try:
        loop.run_until_complete(bot.initialize())
        loop.run_until_complete(bot.run_strategy())
    except KeyboardInterrupt:
        loop.run_until_complete(bot.shutdown())
    except Exception as e:
        logger.error(f"Fatal Error: {e}")
        traceback.print_exc()
